# show a waring on startup if lf is running as a nested instance
%[ $LF_LEVEL -eq 1 ] || echo "WARNING: You're in a nested lf instance!"

# options for shell commands
set shell bash
set shellopts '-eu'
set ifs "\n"

# basic settings
set scrolloff 10
set drawbox

# custom functions
cmd open ${{
    test -L $f && f=$(readlink -f $f)
    case $(file --mime-type $f -b) in
        text/* | application/json | inode/x-empty) $EDITOR $fx;;
        application/x-pie-executable) $fx;;
        application/pdf) zathura $fx;;
        *) for f in $fx; do setsid $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}

# chmod
cmd chmod %{{
    chmod $1 $fx
    lf -remote "send $id reload"
    lf -remote "send unselect"
}}

# y (select for copy) and P to paste soft-link
# d (select for cut) and P to paste hard-link
cmd link %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        # symbolically copy mode is indicating a soft link
        copy) ln -sr -t . -- "$@";;
        # while a move mode is indicating a hard link
        move) ln -t . -- "$@";;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
}}

cmd compile !{{
    set -f
    
    firstFile="$(echo "$fx" | cut -d' ' -f1)"
    firstFileNoExtension="${firstFile%%.*}"
    ext="${firstFile##*.}"
    
    case "$ext" in
        cpp) g++ $fx -o "${firstFileNoExtension}";;
        c) gcc $fx -o "${firstFileNoExtension}";;
        go) go build $f;;
        *) echo "File format not supported";;
    esac
    
    lf -remote "send unselect"
}}

cmd debug !{{
    set -f
    
    firstFile="$(echo "$fx" | cut -d' ' -f1)"
    firstFileNoExtension="${firstFile%%.*}"
    ext="${firstFile##*.}"
    
    case "$ext" in
        cpp) g++ -g $fx -o "${firstFileNoExtension}";;
        c) gcc -g $fx -o "${firstFileNoExtension}";;
        *) echo "File format not supported";;
    esac
    
    lf -remote "send unselect"
}}

cmd code ${{
  code .
}}

# move to trash
%mkdir -p ~/.trash

cmd trash ${{
    for f in $fx; do
        fname="${f##*/}"
        if [ -e ~/.trash/$fname ]; then
            fname+=$RANDOM
        fi
        mv $f ~/.trash/$fname
    done
}}

cmd unarchive ${{
    set -f
    case "$f" in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf "$f";;
        *.tar.gz|*.tgz) tar xzvf "$f";;
        *.tar.xz|*.txz) tar xJvf "$f";;
        *.zip) unzip "$f";;
        *.rar) unrar x "$f";;
        *.7z) 7z x "$f";;
    esac
}}

cmd zip %zip -r "$f" "$f"
cmd tar %tar cvf "$f.tar" "$f"
cmd targz %tar cvzf "$f.tar.gz" "$f"
cmd tarbz %tar cjvf "$f.tar.bz2" "$f"

cmd execute !{{
    set -f
    case "$f" in
        *.go) go run "$f";;
        *) "$f";;
    esac
}}


# unmap default mappings
map c
map w

# archive mappings
map Rz zip 
map Rt tar
map Rg targz
map Rb tarbz
map Ru unarchive

# basic mappings
map A push %mkdir<space>-p<space>
map a push %touch<space>
map ch push :chmod<space>
map cc compile
map cd debug
map C code

map D trash
map P :link
map <c-l> reload
map <c-z> $ kill -STOP $PPID
map U clear
map x $$f
map X execute

map gc cd ~/.config
map gr cd /
map gT cd ~/.trash
